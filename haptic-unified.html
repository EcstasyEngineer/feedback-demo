<!DOCTYPE html>
<html>
<head>
  <title>Haptic Unified - Lovense + Coyote</title>
  <style>
    body { font-family: system-ui; max-width: 900px; margin: 40px auto; padding: 20px; background: #1a1a2e; color: #eee; }
    button { padding: 12px 24px; font-size: 16px; margin: 8px; cursor: pointer; border: none; border-radius: 8px; }
    .connect { background: #4CAF50; color: white; }
    .connect:disabled { background: #666; }
    .activate { background: #ff5722; color: white; }
    .stop { background: #9c27b0; color: white; }
    #status { padding: 16px; margin: 16px 0; border-radius: 8px; background: #16213e; }
    #devices { margin: 16px 0; }
    .device { padding: 12px; margin: 8px 0; background: #0f3460; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; }
    .device.connected { border-left: 4px solid #4CAF50; }
    .device.lovense { border-left-color: #e91e63; }
    .device.coyote { border-left-color: #ffeb3b; }
    .device-type { font-size: 12px; opacity: 0.7; }
    input[type=range] { width: 200px; vertical-align: middle; }
    h1 { color: #e94560; }
    .method { border: 1px solid #333; padding: 20px; margin: 20px 0; border-radius: 12px; }
    .method h3 { margin-top: 0; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .control-group { background: #16213e; padding: 16px; border-radius: 8px; }
    .control-group h4 { margin: 0 0 12px 0; color: #0f4c75; }
    .control-group.coyote-only { border: 1px solid #ffeb3b33; }
    label { display: block; margin: 8px 0; }
    .warning { background: #ff572233; border: 1px solid #ff5722; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px; }
    .badge.lovense { background: #e91e63; }
    .badge.coyote { background: #ffeb3b; color: #000; }
  </style>
</head>
<body>
  <h1>Haptic Unified POC</h1>
  <p>Direct Web Bluetooth control for Lovense (vibration) and DG-Lab Coyote (e-stim)</p>

  <div id="status">Status: Ready</div>

  <div class="method">
    <h3>Connect Device</h3>
    <button class="connect" id="connectDevice">Search & Connect Device</button>
    <button class="connect" id="connectAny" style="background: #666;">Scan All Devices (Debug)</button>
    <p style="font-size: 13px; opacity: 0.7;">Supports: Lovense (LVS-*) and DG-Lab Coyote (D-LAB ESTIM*, 47L*, Coyote*)</p>
  </div>

  <div id="devices">
    <h3>Connected Devices:</h3>
    <div id="deviceList">None</div>
  </div>

  <div class="controls">
    <div class="control-group">
      <h4>Universal Control</h4>
      <label>
        Intensity: <input type="range" id="intensity" min="0" max="100" value="0">
        <span id="intensityVal">0%</span>
      </label>
      <br>
      <button class="activate" id="activate" disabled>Activate</button>
      <button class="stop" id="stop" disabled>Stop</button>
    </div>

    <div class="control-group coyote-only">
      <h4>Coyote E-Stim Settings <span class="badge coyote">Coyote Only</span></h4>
      <label>
        Channel:
        <select id="coyoteChannel">
          <option value="both">Both A+B</option>
          <option value="a">Channel A only</option>
          <option value="b">Channel B only</option>
        </select>
      </label>
      <label>
        Pulse Interval: <input type="range" id="coyoteFreq" min="10" max="500" value="100">
        <span id="coyoteFreqVal">100 ms</span>
      </label>
      <p style="font-size: 11px; opacity: 0.6; margin: 4px 0;">Lower = faster pulses, Higher = slower pulses</p>
      <div class="warning">
        E-stim safety: Always start at 0% and increase slowly!
      </div>
    </div>
  </div>

  <script type="module">
    // ============================================================================
    // Logging
    // ============================================================================
    function log(msg) {
      console.log(msg);
      document.getElementById('status').textContent = 'Status: ' + msg;
    }

    // ============================================================================
    // Device State
    // ============================================================================
    let connectedDevices = [];
    let coyoteInterval = null;

    // ============================================================================
    // Lovense Protocol
    // ============================================================================
    const LOVENSE = {
      filters: [{ namePrefix: 'LVS-' }],
      services: [
        '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART
        '50300001-0024-4bd4-bbd5-a6920e4c5653', // Lush 2
        '53300001-0023-4bd4-bbd5-a6920e4c5653', // Hush
        '54300001-0023-4bd4-bbd5-a6920e4c5653', // Diamo
        '57300001-0023-4bd4-bbd5-a6920e4c5653', // Edge
        '58300001-0023-4bd4-bbd5-a6920e4c5653', // Domi
        '5a300001-0024-4bd4-bbd5-a6920e4c5653', // Osci
        '5a300001-0023-4bd4-bbd5-a6920e4c5653', // Hush variant
        '45300001-0023-4bd4-bbd5-a6920e4c5653', // Max
        '46300001-0023-4bd4-bbd5-a6920e4c5653', // Nora
        '4c300001-0024-4bd4-bbd5-a6920e4c5653', // Lush 3
        '00001800-0000-1000-8000-00805f9b34fb', // Generic Access
        '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute
      ],

      buildCommand(intensity) {
        // Lovense uses 0-20 scale
        return `Vibrate:${Math.round(intensity * 20)};`;
      },

      async connect(device) {
        const server = await device.gatt.connect();
        const services = await server.getPrimaryServices();

        // Find non-generic service
        let targetService = services.find(s =>
          !s.uuid.startsWith('00001800') && !s.uuid.startsWith('00001801')
        ) || services[0];

        const chars = await targetService.getCharacteristics();
        const writeChar = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);

        if (!writeChar) throw new Error('No writable characteristic found');

        return {
          name: device.name,
          type: 'lovense',
          device,
          char: writeChar,
          _active: false,
          async send(intensity) {
            const cmd = LOVENSE.buildCommand(intensity);
            const data = new TextEncoder().encode(cmd);
            await this.char.writeValue(data);
          },
          async stop() {
            this._active = false;
            await this.send(0);
          }
        };
      }
    };

    // ============================================================================
    // Coyote V3 Protocol
    // ============================================================================
    const COYOTE = {
      filters: [
        { namePrefix: 'D-LAB ESTIM' },
        { namePrefix: 'DG-LAB' },
        { namePrefix: '47L' },        // Some Coyote variants
        { namePrefix: 'Coyote' },
      ],
      services: [
        // V3
        '0000180c-0000-1000-8000-00805f9b34fb',
        '0000180a-0000-1000-8000-00805f9b34fb',
        // V2 (both service variants)
        '955a180a-0fe2-f5aa-a094-84b8d4f3e8ad',
        '955a180b-0fe2-f5aa-a094-84b8d4f3e8ad',
        // Generic BLE services (for discovery)
        '00001800-0000-1000-8000-00805f9b34fb',
        '00001801-0000-1000-8000-00805f9b34fb',
      ],
      // V3 UUIDs
      V3: {
        CONTROL_SERVICE: '0000180c-0000-1000-8000-00805f9b34fb',
        WRITE_CHAR: '0000150a-0000-1000-8000-00805f9b34fb',
        NOTIFY_CHAR: '0000150b-0000-1000-8000-00805f9b34fb',
      },
      // V2 UUIDs
      V2: {
        SERVICE: '955a180a-0fe2-f5aa-a094-84b8d4f3e8ad',
        BATTERY: '955a1500-0fe2-f5aa-a094-84b8d4f3e8ad',
        POWER: '955a1504-0fe2-f5aa-a094-84b8d4f3e8ad',
        // Swapped: device labels appear opposite to protocol
        WAVE_A: '955a1506-0fe2-f5aa-a094-84b8d4f3e8ad',
        WAVE_B: '955a1505-0fe2-f5aa-a094-84b8d4f3e8ad',
      },

      encodeFrequency(hz) {
        hz = Math.min(1000, Math.max(10, hz));
        if (hz <= 100) return hz;
        if (hz <= 600) return Math.round((hz - 100) / 5) + 100;
        return Math.round((hz - 600) / 10) + 200;
      },

      buildB0Command(options = {}) {
        const {
          sequence = 0,
          modeA = 0b11,        // absolute set
          modeB = 0b11,        // absolute set
          intensityA = 0,      // 0-200
          intensityB = 0,      // 0-200
          waveFreqA = [100, 100, 100, 100],
          waveIntA = [50, 50, 50, 50],
          waveFreqB = [100, 100, 100, 100],
          waveIntB = [50, 50, 50, 50],
        } = options;

        const cmd = new Uint8Array(20);
        cmd[0] = 0xB0;
        cmd[1] = (sequence << 4) | (modeB << 2) | modeA;
        cmd[2] = Math.min(200, Math.max(0, intensityA));
        cmd[3] = Math.min(200, Math.max(0, intensityB));

        for (let i = 0; i < 4; i++) {
          cmd[4 + i] = this.encodeFrequency(waveFreqA[i]);
          cmd[8 + i] = Math.min(100, Math.max(0, waveIntA[i]));
        }
        for (let i = 0; i < 4; i++) {
          cmd[12 + i] = this.encodeFrequency(waveFreqB[i]);
          cmd[16 + i] = Math.min(100, Math.max(0, waveIntB[i]));
        }

        return cmd;
      },

      async connect(device) {
        let server;
        let services;

        // Try connecting with retry
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            console.log(`Connection attempt ${attempt}...`);
            server = await device.gatt.connect();
            // Small delay to let connection stabilize
            await new Promise(r => setTimeout(r, 500));
            services = await server.getPrimaryServices();
            break; // Success
          } catch (e) {
            console.warn(`Attempt ${attempt} failed:`, e.message);
            if (attempt === 3) throw e;
            await new Promise(r => setTimeout(r, 1000));
          }
        }
        console.log('Available services:', services.map(s => s.uuid));

        // Find which version based on available services
        let version = null;
        let service = null;

        const v3Service = services.find(s => s.uuid === this.V3.CONTROL_SERVICE);
        const v2ServiceA = services.find(s => s.uuid === this.V2.SERVICE);
        const v2ServiceB = services.find(s => s.uuid === '955a180b-0fe2-f5aa-a094-84b8d4f3e8ad');

        if (v3Service) {
          service = v3Service;
          version = 'v3';
          console.log('Coyote V3 detected');
        } else if (v2ServiceB) {
          // Try service B first (has writable chars)
          service = v2ServiceB;
          version = 'v2';
          console.log('Coyote V2 (service B) detected');
        } else if (v2ServiceA) {
          service = v2ServiceA;
          version = 'v2';
          console.log('Coyote V2 (service A) detected');
        } else {
          // Dump all services for debugging
          console.log('=== ALL AVAILABLE SERVICES ===');
          for (const svc of services) {
            console.log('Service:', svc.uuid);
            try {
              const chars = await svc.getCharacteristics();
              for (const c of chars) {
                console.log('  Char:', c.uuid, {
                  read: c.properties.read,
                  write: c.properties.write,
                  writeNoResp: c.properties.writeWithoutResponse,
                  notify: c.properties.notify
                });
              }
            } catch (ce) {
              console.log('  (could not enumerate characteristics)');
            }
          }
          throw new Error('No known Coyote service found. Check console for available services.');
        }

        if (version === 'v3') {
          return this.connectV3(device, service);
        } else {
          return this.connectV2(device, server, service, version);
        }
      },

      async connectV3(device, service) {
        const writeChar = await service.getCharacteristic(this.V3.WRITE_CHAR);

        try {
          const notifyChar = await service.getCharacteristic(this.V3.NOTIFY_CHAR);
          await notifyChar.startNotifications();
          notifyChar.addEventListener('characteristicvaluechanged', (event) => {
            const data = new Uint8Array(event.target.value.buffer);
            if (data[0] === 0xB1) {
              console.log(`Coyote V3 feedback: A=${data[2]}, B=${data[3]}`);
            }
          });
        } catch (e) {
          console.warn('Could not set up V3 notifications:', e);
        }

        return {
          name: device.name,
          type: 'coyote',
          version: 'v3',
          device,
          char: writeChar,
          frequency: 100,
          waveIntensity: 50,
          channel: 'both',
          _interval: null,

          async send(intensity, options = {}) {
            const freq = options.frequency || this.frequency;
            const waveInt = options.waveIntensity || this.waveIntensity;
            const channel = options.channel || this.channel;

            const level = Math.round(intensity * 200);
            const freqArr = [freq, freq, freq, freq];
            const waveArr = [waveInt, waveInt, waveInt, waveInt];

            const cmd = COYOTE.buildB0Command({
              sequence: 1,
              intensityA: (channel === 'both' || channel === 'a') ? level : 0,
              intensityB: (channel === 'both' || channel === 'b') ? level : 0,
              waveFreqA: freqArr,
              waveIntA: waveArr,
              waveFreqB: freqArr,
              waveIntB: waveArr,
            });

            await this.char.writeValue(cmd);
          },

          startLoop(getIntensity, getOptions) {
            this.stopLoop();
            this._interval = setInterval(async () => {
              try {
                await this.send(getIntensity(), getOptions());
              } catch (e) {
                console.error('Coyote send error:', e);
              }
            }, 100);
          },

          stopLoop() {
            if (this._interval) {
              clearInterval(this._interval);
              this._interval = null;
            }
          },

          async stop() {
            this.stopLoop();
            const cmd = COYOTE.buildB0Command({ intensityA: 0, intensityB: 0 });
            await this.char.writeValue(cmd);
          }
        };
      },

      async connectV2(device, server, service, version) {
        // Try to get all services and find writable characteristics
        const services = await server.getPrimaryServices();
        console.log('=== SCANNING ALL SERVICES FOR WRITABLE CHARS ===');

        let allWritableChars = [];
        for (const svc of services) {
          try {
            const chars = await svc.getCharacteristics();
            for (const c of chars) {
              const props = {
                read: c.properties.read,
                write: c.properties.write,
                writeNoResp: c.properties.writeWithoutResponse,
                notify: c.properties.notify
              };
              console.log(`  ${svc.uuid} -> ${c.uuid}`, props);
              if (c.properties.write || c.properties.writeWithoutResponse) {
                allWritableChars.push({ service: svc, char: c });
              }
            }
          } catch (e) {
            console.log(`  ${svc.uuid}: could not enumerate`);
          }
        }

        console.log('Total writable characteristics found:', allWritableChars.length);

        // Try known V2 characteristics first
        let powerChar, waveAChar, waveBChar;

        try {
          powerChar = await service.getCharacteristic(this.V2.POWER);
          waveAChar = await service.getCharacteristic(this.V2.WAVE_A);
          waveBChar = await service.getCharacteristic(this.V2.WAVE_B);
          console.log('Found known V2 characteristics');
        } catch (e) {
          console.error('Could not find V2 characteristics:', e);
          throw new Error('V2 characteristics not found. Device may use a different protocol.');
        }

        console.log('V2 characteristics acquired:', {
          power: powerChar.uuid,
          waveA: waveAChar.uuid,
          waveB: waveBChar.uuid
        });

        const coyoteDevice = {
          name: device.name,
          type: 'coyote',
          version: 'v2',
          device,
          server,
          powerChar,
          waveAChar,
          waveBChar,
          frequency: 100,
          waveIntensity: 50,
          channel: 'both',
          _interval: null,
          _connected: true,

          // V2 power encoding: A in high bits (11-21), B in low bits (0-10)
          buildPowerCmd(levelA, levelB) {
            const a = Math.min(2047, Math.max(0, levelA));
            const b = Math.min(2047, Math.max(0, levelB));
            const byte0 = b & 0xFF;
            const byte1 = ((b >> 8) & 0x07) | ((a & 0x1F) << 3);
            const byte2 = (a >> 5) & 0x3F;
            return new Uint8Array([byte0, byte1, byte2]);
          },

          // V2 waveform: Ax (pulses), Ay (timing), Az (amplitude)
          buildWaveCmd(ax, ay, az) {
            ax = Math.min(31, Math.max(0, ax));
            ay = Math.min(255, Math.max(0, ay));
            az = Math.min(31, Math.max(5, az));
            const byte0 = (ax & 0x1F) | ((ay & 0x07) << 5);
            const byte1 = (ay >> 3) & 0xFF;
            const byte2 = az & 0x1F;
            return new Uint8Array([byte0, byte1, byte2]);
          },

          // V2 power encoding: A in high bits (11-21), B in low bits (0-10)
          encodePower(a, b) {
            a = Math.min(2047, Math.max(0, a));
            b = Math.min(2047, Math.max(0, b));
            const byte0 = b & 0xFF;
            const byte1 = ((b >> 8) & 0x07) | ((a & 0x1F) << 3);
            const byte2 = (a >> 5) & 0x3F;
            return new Uint8Array([byte0, byte1, byte2]);
          },

          // Official V2 waveform: X (pulses 0-31), Y (interval 0-1023), Z (width 0-31)
          // Bits 19-15: Z, Bits 14-5: Y, Bits 4-0: X
          encodeWave(x, y, z) {
            x = Math.min(31, Math.max(0, x));
            y = Math.min(1023, Math.max(0, y));
            z = Math.min(31, Math.max(0, z));
            const byte0 = (x & 0x1F) | ((y & 0x07) << 5);
            const byte1 = (y >> 3) & 0x7F;
            const byte2 = z & 0x1F;
            return new Uint8Array([byte0, byte1, byte2]);
          },

          async send(intensity, options = {}) {
            if (!this._connected) return;

            const channel = options.channel || this.channel;
            // "Frequency" slider is actually Y = ms interval between pulses
            const intervalMs = options.frequency || this.frequency || 100;

            // V2 range is 0-2047, use 50% max for testing
            const level = Math.round(intensity * 1024);

            const powerA = (channel === 'both' || channel === 'a') ? level : 0;
            const powerB = (channel === 'both' || channel === 'b') ? level : 0;

            // V2 waveform: X=pulses, Y=interval(ms), Z=width
            const x = 10;  // 10 pulses per burst
            const y = intervalMs;  // ms between bursts (from slider)
            const z = 10;  // pulse width (10 * 5μs = 50μs)

            try {
              // Set waveform for BOTH channels
              const waveCmd = this.encodeWave(x, y, z);
              if (channel === 'both' || channel === 'a') {
                await this.waveAChar.writeValueWithoutResponse(waveCmd);
              }
              if (channel === 'both' || channel === 'b') {
                await this.waveBChar.writeValueWithoutResponse(waveCmd);
              }

              // Set power
              const powerCmd = this.encodePower(powerA, powerB);
              await this.powerChar.writeValueWithoutResponse(powerCmd);
            } catch (e) {
              if (e.message.includes('disconnected')) {
                console.warn('Device disconnected, stopping loop');
                this._connected = false;
                this.stopLoop();
              } else {
                console.error('Write failed:', e);
              }
            }
          },

          startLoop(getIntensity, getOptions) {
            this.stopLoop();
            this._connected = true;
            this._interval = setInterval(async () => {
              if (!this._connected) {
                this.stopLoop();
                return;
              }
              await this.send(getIntensity(), getOptions());
            }, 100);  // V2 protocol requires updates every 100ms or output stops
          },

          stopLoop() {
            if (this._interval) {
              clearInterval(this._interval);
              this._interval = null;
            }
          },

          async stop() {
            this.stopLoop();
            if (this._connected) {
              try {
                await this.powerChar.writeValue(this.buildPowerCmd(0, 0));
              } catch (e) {
                console.warn('Stop failed (device may be disconnected)');
              }
            }
          }
        };

        // Listen for disconnect
        device.addEventListener('gattserverdisconnected', () => {
          console.warn('Coyote disconnected');
          coyoteDevice._connected = false;
          coyoteDevice.stopLoop();
        });

        return coyoteDevice;
      }
    };

    // ============================================================================
    // Unified Connection
    // ============================================================================
    document.getElementById('connectDevice').onclick = async () => {
      try {
        log('Requesting Bluetooth device...');

        // Combined filters for both device types
        const device = await navigator.bluetooth.requestDevice({
          filters: [
            ...LOVENSE.filters,
            ...COYOTE.filters,
          ],
          optionalServices: [
            ...LOVENSE.services,
            ...COYOTE.services,
          ]
        });

        log('Connecting to: ' + device.name);

        let connectedDevice;

        const name = device.name || '';
        const isCoyote = name.startsWith('D-LAB') || name.startsWith('DG-LAB') ||
                         name.startsWith('47L') || name.startsWith('Coyote') ||
                         name.toLowerCase().includes('estim');
        const isLovense = name.startsWith('LVS-');

        if (isLovense) {
          connectedDevice = await LOVENSE.connect(device);
          log(`SUCCESS: Lovense ${device.name} connected`);
        } else if (isCoyote) {
          connectedDevice = await COYOTE.connect(device);
          log(`SUCCESS: Coyote ${device.name} connected`);
        } else {
          // Unknown - let user try to connect as Coyote (more complex protocol)
          log(`Unknown device "${device.name}" - attempting Coyote protocol...`);
          try {
            connectedDevice = await COYOTE.connect(device);
            connectedDevice.type = 'coyote (unknown)';
          } catch (e) {
            log(`Coyote failed, trying Lovense...`);
            connectedDevice = await LOVENSE.connect(device);
            connectedDevice.type = 'lovense (unknown)';
          }
        }

        connectedDevices.push(connectedDevice);
        updateDeviceList();
        enableControls();

      } catch (e) {
        log('Error: ' + e.message);
        console.error(e);
      }
    };

    // Debug: scan ALL bluetooth devices
    document.getElementById('connectAny').onclick = async () => {
      try {
        log('Scanning ALL Bluetooth devices...');

        const device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [
            ...LOVENSE.services,
            ...COYOTE.services,
          ]
        });

        log(`Found: "${device.name}" - connecting...`);
        console.log('Device:', device);

        // Try to detect and connect
        let connectedDevice;
        const name = device.name || '';
        const isCoyote = name.startsWith('D-LAB') || name.startsWith('DG-LAB') ||
                         name.startsWith('47L') || name.startsWith('Coyote') ||
                         name.toLowerCase().includes('estim');
        const isLovense = name.startsWith('LVS-');

        if (isLovense) {
          connectedDevice = await LOVENSE.connect(device);
        } else if (isCoyote) {
          connectedDevice = await COYOTE.connect(device);
        } else {
          // Unknown - try Coyote first, fall back to Lovense
          log(`Unknown device - trying Coyote protocol first...`);
          try {
            connectedDevice = await COYOTE.connect(device);
            connectedDevice.type = 'coyote?';
          } catch (e) {
            console.log('Coyote failed:', e);
            log(`Coyote failed, trying Lovense...`);
            connectedDevice = await LOVENSE.connect(device);
            connectedDevice.type = 'lovense?';
          }
        }

        log(`SUCCESS: ${device.name} connected as ${connectedDevice.type}`);
        connectedDevices.push(connectedDevice);
        updateDeviceList();
        enableControls();

      } catch (e) {
        log('Error: ' + e.message);
        console.error(e);
      }
    };

    // ============================================================================
    // UI Updates
    // ============================================================================
    function updateDeviceList() {
      const list = document.getElementById('deviceList');
      if (connectedDevices.length === 0) {
        list.innerHTML = 'None';
        return;
      }
      list.innerHTML = connectedDevices.map(d => `
        <div class="device connected ${d.type}">
          <span>${d.name} <span class="device-type">${d.type}${d.version ? ' ' + d.version : ''}</span></span>
          <span class="badge ${d.type}">${d.type === 'lovense' ? 'Vibration' : 'E-Stim'}</span>
        </div>
      `).join('');
    }

    function enableControls() {
      document.getElementById('activate').disabled = false;
      document.getElementById('stop').disabled = false;
    }

    // Intensity slider - update display and send to active Lovense devices
    // Uses a lock to prevent "GATT operation already in progress" errors
    let lovenseSending = false;
    let lovensePending = null; // Queue latest value while sending
    const sendLovenseUpdate = async () => {
      if (lovenseSending) {
        lovensePending = document.getElementById('intensity').value / 100;
        return;
      }
      lovenseSending = true;
      const intensity = document.getElementById('intensity').value / 100;
      const devices = connectedDevices.filter(d => d.type === 'lovense' && d._active);
      for (const d of devices) {
        try {
          await d.send(intensity);
        } catch (err) {
          console.error('Lovense update error:', err);
        }
      }
      lovenseSending = false;
      // If a value was queued while sending, send it now
      if (lovensePending !== null) {
        const pending = lovensePending;
        lovensePending = null;
        sendLovenseUpdate();
      }
    };
    document.getElementById('intensity').oninput = (e) => {
      document.getElementById('intensityVal').textContent = e.target.value + '%';
      sendLovenseUpdate();
    };

    // Coyote pulse interval slider
    document.getElementById('coyoteFreq').oninput = (e) => {
      document.getElementById('coyoteFreqVal').textContent = e.target.value + ' ms';
      connectedDevices.filter(d => d.type === 'coyote').forEach(d => {
        d.frequency = parseInt(e.target.value);
      });
    };

    // Coyote channel selector
    document.getElementById('coyoteChannel').onchange = (e) => {
      connectedDevices.filter(d => d.type === 'coyote').forEach(d => {
        d.channel = e.target.value;
      });
    };

    // ============================================================================
    // Activation
    // ============================================================================
    function getIntensity() {
      return document.getElementById('intensity').value / 100;
    }

    function getCoyoteOptions() {
      return {
        frequency: parseInt(document.getElementById('coyoteFreq').value),
        channel: document.getElementById('coyoteChannel').value,
      };
    }

    document.getElementById('activate').onclick = async () => {
      const intensity = getIntensity();
      log('Activating at ' + (intensity * 100).toFixed(0) + '%');

      for (const dev of connectedDevices) {
        try {
          if (dev.type === 'lovense') {
            dev._active = true;
            await dev.send(intensity);
          } else if (dev.type === 'coyote') {
            // Coyote needs continuous updates every 100ms
            dev.startLoop(getIntensity, getCoyoteOptions);
          }
        } catch (e) {
          console.error(`Error activating ${dev.name}:`, e);
        }
      }
    };

    document.getElementById('stop').onclick = async () => {
      log('Stopping all devices...');

      for (const dev of connectedDevices) {
        try {
          await dev.stop();
        } catch (e) {
          console.error(`Error stopping ${dev.name}:`, e);
        }
      }

      log('Stopped');
    };

    // ============================================================================
    // Cleanup on page unload
    // ============================================================================
    window.addEventListener('beforeunload', () => {
      connectedDevices.forEach(dev => {
        try { dev.stop(); } catch (e) {}
      });
    });
  </script>
</body>
</html>
