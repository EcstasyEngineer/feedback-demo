<!DOCTYPE html>
<html>
<head>
  <title>Haptic POC - Web Bluetooth Direct</title>
  <style>
    body { font-family: system-ui; max-width: 800px; margin: 40px auto; padding: 20px; background: #1a1a2e; color: #eee; }
    button { padding: 12px 24px; font-size: 16px; margin: 8px; cursor: pointer; border: none; border-radius: 8px; }
    .connect { background: #4CAF50; color: white; }
    .connect:disabled { background: #666; }
    .scan { background: #2196F3; color: white; }
    .activate { background: #ff5722; color: white; }
    .stop { background: #9c27b0; color: white; }
    #status { padding: 16px; margin: 16px 0; border-radius: 8px; background: #16213e; }
    #devices { margin: 16px 0; }
    .device { padding: 12px; margin: 8px 0; background: #0f3460; border-radius: 8px; }
    .device.connected { border-left: 4px solid #4CAF50; }
    input[type=range] { width: 200px; }
    h1 { color: #e94560; }
    h2 { color: #0f4c75; }
    .method { border: 1px solid #333; padding: 20px; margin: 20px 0; border-radius: 12px; }
    .method h3 { margin-top: 0; }
    code { background: #0a0a0a; padding: 2px 6px; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>Haptic Device POC</h1>

  <div id="status">Status: Ready</div>

  <!-- Method 1: Intiface WebSocket (what Shibbydex uses) -->
  <div class="method">
    <h3>Method 1: Intiface Central (WebSocket)</h3>
    <p>Requires <a href="https://intiface.com/central/" target="_blank">Intiface Central</a> running locally.</p>
    <button class="connect" id="connectIntiface">Connect to Intiface</button>
    <button class="scan" id="scanIntiface" disabled>Start Scanning</button>
  </div>

  <!-- Method 2: Direct Web Bluetooth (no Intiface needed) -->
  <div class="method">
    <h3>Method 2: Direct Web Bluetooth (Browser Native)</h3>
    <p>Uses browser's Web Bluetooth API directly. No Intiface needed!</p>
    <button class="connect" id="connectBluetooth">Search & Connect Device</button>
  </div>

  <div id="devices">
    <h3>Connected Devices:</h3>
    <div id="deviceList">None</div>
  </div>

  <div class="method">
    <h3>Control</h3>
    <label>Intensity: <input type="range" id="intensity" min="0" max="100" value="50"> <span id="intensityVal">50%</span></label>
    <br><br>
    <button class="activate" id="activate" disabled>Activate Vibration</button>
    <button class="stop" id="stop" disabled>Stop</button>
  </div>

  <script type="module">
    // ============================================================================
    // Status logging
    // ============================================================================
    function log(msg) {
      console.log(msg);
      document.getElementById('status').textContent = 'Status: ' + msg;
    }

    // ============================================================================
    // Shared state
    // ============================================================================
    let connectedDevices = [];
    let bluetoothDevice = null;
    let vibrationChar = null;

    // ============================================================================
    // METHOD 1: Intiface WebSocket Connection (Buttplug protocol)
    // ============================================================================
    let ws = null;
    let msgId = 1;

    document.getElementById('connectIntiface').onclick = async () => {
      try {
        log('Connecting to Intiface Central...');
        ws = new WebSocket('ws://localhost:12345');

        ws.onopen = () => {
          log('WebSocket connected, requesting server info...');
          // Buttplug handshake
          ws.send(JSON.stringify([{
            RequestServerInfo: {
              Id: msgId++,
              ClientName: "HapticPOC",
              MessageVersion: 3
            }
          }]));
        };

        ws.onmessage = (event) => {
          const msgs = JSON.parse(event.data);
          console.log('Received:', msgs);

          msgs.forEach(msg => {
            if (msg.ServerInfo) {
              log('Connected to: ' + msg.ServerInfo.ServerName);
              document.getElementById('scanIntiface').disabled = false;
            }
            if (msg.DeviceAdded) {
              const dev = msg.DeviceAdded;
              log('Device found: ' + dev.DeviceName);
              connectedDevices.push({
                index: dev.DeviceIndex,
                name: dev.DeviceName,
                type: 'intiface'
              });
              updateDeviceList();
              enableControls();
            }
            if (msg.DeviceList) {
              msg.DeviceList.Devices.forEach(dev => {
                connectedDevices.push({
                  index: dev.DeviceIndex,
                  name: dev.DeviceName,
                  type: 'intiface'
                });
              });
              updateDeviceList();
              if (connectedDevices.length > 0) enableControls();
            }
          });
        };

        ws.onerror = () => log('WebSocket error - is Intiface running?');
        ws.onclose = () => log('WebSocket closed');

      } catch (e) {
        log('Error: ' + e.message);
      }
    };

    document.getElementById('scanIntiface').onclick = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        log('Starting device scan...');
        ws.send(JSON.stringify([{
          StartScanning: { Id: msgId++ }
        }]));
        // Also request existing devices
        ws.send(JSON.stringify([{
          RequestDeviceList: { Id: msgId++ }
        }]));
      }
    };

    // ============================================================================
    // METHOD 2: Direct Web Bluetooth
    // ============================================================================
    // Known device service UUIDs
    const KNOWN_SERVICES = {
      // Lovense (Nordic UART)
      lovense: {
        service: '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
        tx: '6e400002-b5a3-f393-e0a9-e50e24dcca9e',
        rx: '6e400003-b5a3-f393-e0a9-e50e24dcca9e',
        cmd: (level) => `Vibrate:${Math.round(level * 20)};`
      },
      // Alternative Lovense service
      lovense2: {
        service: '50300001-0024-4bd4-bbd5-a6920e4c5653',
        tx: '50300002-0024-4bd4-bbd5-a6920e4c5653',
        cmd: (level) => `Vibrate:${Math.round(level * 20)};`
      },
      // WeVibe
      wevibe: {
        service: 'f000bb03-0451-4000-b000-000000000000',
        tx: 'f000c000-0451-4000-b000-000000000000',
        cmd: (level) => new Uint8Array([0x0f, 0x03, 0x00, Math.round(level * 100), 0x00])
      },
      // Kiiroo (Onyx, etc)
      kiiroo: {
        service: '88f80580-0000-01e6-aace-0002a5d5c51b',
        tx: '88f80581-0000-01e6-aace-0002a5d5c51b',
        cmd: (level) => new Uint8Array([Math.round(level * 100)])
      },
      // Generic vibrator (many Chinese toys)
      generic: {
        service: '0000fff0-0000-1000-8000-00805f9b34fb',
        tx: '0000fff1-0000-1000-8000-00805f9b34fb',
        cmd: (level) => new Uint8Array([0x03, 0xff, Math.round(level * 100)])
      }
    };

    let deviceProtocol = null;

    // Comprehensive Lovense service UUIDs (each model uses different one)
    // Pattern: 5x300001-00yy-4bd4-bbd5-a6920e4c5653
    const LOVENSE_SERVICES = [
      // Nordic UART (older devices like Nora, Lush 1st gen)
      '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
      // Lovense-specific services (different models)
      '50300001-0024-4bd4-bbd5-a6920e4c5653', // Lush 2
      '53300001-0023-4bd4-bbd5-a6920e4c5653', // Hush
      '54300001-0023-4bd4-bbd5-a6920e4c5653', // Diamo
      '55300001-0023-4bd4-bbd5-a6920e4c5653', //
      '56300001-0023-4bd4-bbd5-a6920e4c5653', //
      '57300001-0023-4bd4-bbd5-a6920e4c5653', // Edge
      '58300001-0023-4bd4-bbd5-a6920e4c5653', // Domi
      '59300001-0023-4bd4-bbd5-a6920e4c5653', //
      '5a300001-0024-4bd4-bbd5-a6920e4c5653', // Osci
      '5a300001-0023-4bd4-bbd5-a6920e4c5653', // variant
      '45300001-0023-4bd4-bbd5-a6920e4c5653', // Max
      '46300001-0023-4bd4-bbd5-a6920e4c5653', // Nora
      '41300001-0023-4bd4-bbd5-a6920e4c5653', // Ambi
      '42300001-0023-4bd4-bbd5-a6920e4c5653', //
      '43300001-0023-4bd4-bbd5-a6920e4c5653', //
      '44300001-0023-4bd4-bbd5-a6920e4c5653', //
      '4c300001-0024-4bd4-bbd5-a6920e4c5653', // Lush 3
      '4f300001-0023-4bd4-bbd5-a6920e4c5653', //
      // Generic BLE
      '00001800-0000-1000-8000-00805f9b34fb', // Generic Access
      '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute
    ];

    // Corresponding TX characteristic UUIDs (same prefix, ends in 2)
    const LOVENSE_TX_CHARS = [
      '6e400002-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART TX
      '50300002-0024-4bd4-bbd5-a6920e4c5653',
      '53300002-0023-4bd4-bbd5-a6920e4c5653',
      '54300002-0023-4bd4-bbd5-a6920e4c5653',
      '55300002-0023-4bd4-bbd5-a6920e4c5653',
      '56300002-0023-4bd4-bbd5-a6920e4c5653',
      '57300002-0023-4bd4-bbd5-a6920e4c5653',
      '58300002-0023-4bd4-bbd5-a6920e4c5653',
      '59300002-0023-4bd4-bbd5-a6920e4c5653',
      '5a300002-0024-4bd4-bbd5-a6920e4c5653',
      '5a300002-0023-4bd4-bbd5-a6920e4c5653',
      '45300002-0023-4bd4-bbd5-a6920e4c5653',
      '46300002-0023-4bd4-bbd5-a6920e4c5653',
      '41300002-0023-4bd4-bbd5-a6920e4c5653',
      '42300002-0023-4bd4-bbd5-a6920e4c5653',
      '43300002-0023-4bd4-bbd5-a6920e4c5653',
      '44300002-0023-4bd4-bbd5-a6920e4c5653',
      '4c300002-0024-4bd4-bbd5-a6920e4c5653',
      '4f300002-0023-4bd4-bbd5-a6920e4c5653',
    ];

    document.getElementById('connectBluetooth').onclick = async () => {
      try {
        log('Requesting Bluetooth device...');

        // Filter for Lovense devices specifically
        bluetoothDevice = await navigator.bluetooth.requestDevice({
          filters: [
            { namePrefix: 'LVS-' },
          ],
          optionalServices: LOVENSE_SERVICES
        });

        log('Connecting to: ' + bluetoothDevice.name);

        const server = await bluetoothDevice.gatt.connect();
        log('GATT connected, probing services...');

        // First, get all available services we have permission for
        const services = await server.getPrimaryServices();
        console.log('Found services:', services.map(s => s.uuid));

        if (services.length === 0) {
          log('No services accessible. Device may need pairing first.');
          alert('No services found. Try:\n1. Pair device in system Bluetooth settings first\n2. Make sure device is in pairing mode\n3. Check browser permissions');
          return;
        }

        // Look for Lovense-specific service (not generic access/attribute)
        let lovenseService = null;
        for (const svc of services) {
          // Skip generic BLE services
          if (svc.uuid.startsWith('00001800') || svc.uuid.startsWith('00001801')) {
            continue;
          }
          lovenseService = svc;
          log(`Found Lovense service: ${svc.uuid}`);
          break;
        }

        if (!lovenseService) {
          // Fall back to first service
          lovenseService = services[0];
          log(`Using fallback service: ${lovenseService.uuid}`);
        }

        // Get characteristics
        const chars = await lovenseService.getCharacteristics();
        console.log('Characteristics:', chars.map(c => ({
          uuid: c.uuid,
          props: {
            write: c.properties.write,
            writeWithoutResponse: c.properties.writeWithoutResponse,
            read: c.properties.read,
            notify: c.properties.notify
          }
        })));

        // Find writable characteristic (TX)
        vibrationChar = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);

        if (!vibrationChar) {
          log('No writable characteristic found!');
          alert('Device connected but no writable characteristic.\nService: ' + lovenseService.uuid);
          return;
        }

        log(`Found TX characteristic: ${vibrationChar.uuid}`);

        // Lovense command function
        const lovenseCmd = (level) => `Vibrate:${Math.round(level * 20)};`;

        connectedDevices.push({
          name: bluetoothDevice.name,
          type: 'bluetooth',
          protocol: 'lovense',
          device: bluetoothDevice,
          char: vibrationChar,
          cmd: lovenseCmd
        });

        log(`SUCCESS: Connected to ${bluetoothDevice.name}`);
        updateDeviceList();
        enableControls();

      } catch (e) {
        log('Bluetooth error: ' + e.message);
        console.error(e);

        if (e.message.includes('No Services')) {
          alert('No services found. The device may use a service UUID not in our list.\n\nDevice name: ' + (bluetoothDevice?.name || 'unknown') + '\n\nTry using Intiface Central instead (Method 1).');
        }
      }
    };

    // ============================================================================
    // Device control
    // ============================================================================
    function updateDeviceList() {
      const list = document.getElementById('deviceList');
      if (connectedDevices.length === 0) {
        list.innerHTML = 'None';
        return;
      }
      list.innerHTML = connectedDevices.map(d =>
        `<div class="device connected">${d.name} (${d.type})</div>`
      ).join('');
    }

    function enableControls() {
      document.getElementById('activate').disabled = false;
      document.getElementById('stop').disabled = false;
    }

    document.getElementById('intensity').oninput = (e) => {
      document.getElementById('intensityVal').textContent = e.target.value + '%';
    };

    document.getElementById('activate').onclick = () => {
      const intensity = document.getElementById('intensity').value / 100;
      log('Activating at ' + (intensity * 100).toFixed(0) + '%');

      connectedDevices.forEach(dev => {
        if (dev.type === 'intiface' && ws) {
          // Buttplug ScalarCmd for vibration
          ws.send(JSON.stringify([{
            ScalarCmd: {
              Id: msgId++,
              DeviceIndex: dev.index,
              Scalars: [{ Index: 0, Scalar: intensity, ActuatorType: "Vibrate" }]
            }
          }]));
        }

        if (dev.type === 'bluetooth' && dev.char && dev.cmd) {
          const cmd = dev.cmd(intensity);
          const encoder = new TextEncoder();
          const data = typeof cmd === 'string' ? encoder.encode(cmd) : cmd;
          dev.char.writeValue(data).catch(e => console.error('Write failed:', e));
        }
      });
    };

    document.getElementById('stop').onclick = () => {
      log('Stopping...');

      connectedDevices.forEach(dev => {
        if (dev.type === 'intiface' && ws) {
          ws.send(JSON.stringify([{
            StopDeviceCmd: {
              Id: msgId++,
              DeviceIndex: dev.index
            }
          }]));
        }

        if (dev.type === 'bluetooth' && dev.char && dev.cmd) {
          const cmd = dev.cmd(0); // Zero intensity = stop
          const encoder = new TextEncoder();
          const data = typeof cmd === 'string' ? encoder.encode(cmd) : cmd;
          dev.char.writeValue(data).catch(e => console.error('Write failed:', e));
        }
      });
    };
  </script>
</body>
</html>
